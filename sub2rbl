#!/bin/sh
#
# sub2rbl -> Subscribe to IP or CIDR (net) RBLs; auto-integrates into iptables - @robzr
#
#   https://github.com/robzr/sub2rbl
#
# Recommended to run out of cron periodically, using default parameters.
#
# Dependencies: curl (33k) & ipset (200k) needed for basic operation
#               ca-certificates (186k) & openssl-util (200kb) needed if using HTTPS RBLs
# needed for basic operation

# for loading variables from uci (with default value)
uciLoad () { local gU; gU=`uci -q get 'sub2rbl.@[0]'."$1"` || gU="$2"; eval $1=\'$gU\';}

# Make changes to these uci values in /etc/config/sub2rbl
uciLoad setName sub2rbl
uciLoad netSetName "$setName"-net
uciLoad logLevel 1
uciLoad logFacility authpriv.notice
uciLoad firewallHookChain input_wan_rule
uciLoad firewallHookPosition 1
uciLoad firewallTarget DROP

# Advanced settings - not documented in sample config
uciLoad logTag "sub2rbl[$$]"
uciLoad ipsetArgs "maxelem 32768"
uciLoad curlArgs "-sSm15"

# Functions 
#
logLine () {
  [ $1 -gt $logLevel ] && return ; shift
  if [ "$logFacility" = "stdout" ] ; then echo "$@"
  elif [ "$logFacility" = "stderr" ] ; then echo "$@" >&2
  else logger -t "$logTag" -p "$logFacility" "$@"
  fi
}

# Arg: $1=logLevel, $2=setName, $3=setType (ip or net)
createSet () {
  local useLogLevel="$1" set="$2" setType="$3"
  ipset list -q -n "$set" >/dev/null || {
    logLine $useLogLevel "Creating ipset $set"
    ipset create "$set" hash:"$setType" $ipsetArgs
} }

# Arg: $1=logLevel, $2=setName
removeSet () {
  local useLogLevel=$1 set="$2" 
  ipset list -q -n "$set" >/dev/null && {
    logLine $useLogLevel "Destroying ipset $set"
    ipset destroy "$set"
} }

# Arg: 1=$setName
setupIPTables () {
  local set="$1"
  if [ $firewallHookPosition -ge 0 ] ; then
    if ! iptables -C "$firewallHookChain" -m set --match-set "$set" src -j "$firewallTarget" 2>/dev/null ; then
      logLine 1 "Inserting iptables rule for $set into chain $firewallHookChain"
      if [ $firewallHookPosition = 0 ] ; then
        iptables -A "$firewallHookChain" -m set --match-set "$set" src -j "$firewallTarget"
      else
        iptables -I "$firewallHookChain" $firewallHookPosition -m set --match-set "$set" src -j "$firewallTarget"
  fi ; fi ; fi
}

# Arg: 1=$setName
removeFromIPTables () {
  local set="$1"
  if [ $firewallHookPosition -ge 0 ] ; then
    if iptables -C "$firewallHookChain" -m set --match-set "$set" src -j "$firewallTarget" 2>/dev/null ; then
      logLine 1 "Removing iptables rule for $set from chain $firewallHookChain"
      iptables -D "$firewallHookChain" -m set --match-set "$set" src -j "$firewallTarget"
  fi ; fi
}

printUsage () {
  cat <<-_EOF_
	Usage: sub2rbl [-C ...] [-f ...] [-F #] [-j ...] [-l #] [-s ...] [-w] [URL ...]
	  -C ... firewall chain to hook into (def: $firewallHookChain)
	  -f ... log facility (syslog facility or stdout/stderr) (def: $logFacility)
	  -F #   firewall chain hook position (def: $firewallHookPosition)
	  -j ... firewall target when matching the set (def: $firewallTarget)
	  -l #   log level - 0=off, 1=standard, 2=verbose (def: $logLevel)
	  -s ... ipset name
	  -w     wipe ipset and iptables rule (do not process RBLs)
	  URL(s) RBL URLs - using command line RBL URLs will override uci entries
	_EOF_
}


# Logic begins
#
wipe=false
while getopts C:f:F:hj:l:s:w arg ; do
  case "$arg" in
    C) firewallHookChain=$OPTARG ;;
    f) logFacility=$OPTARG ;;
    F) firewallHookPosition=$OPTARG ;;
    j) firewallTarget=$OPTARG ;;
    l) logLevel=$OPTARG ;;
    s) setName=$OPTARG ;;
    w) wipe=true ;;
    *) printUsage
      exit 254
  esac
shift `expr $OPTIND - 1`
done  

if $wipe ; then
  logLine 2 "Wiping sub2rbl from iptables and ipset"
  for tempSet in "$setName" "$netSetName" ; do
    removeFromIPTables "$tempSet"
    removeSet 1 "$tempSet"
  done
  exit
fi

rblList="$@"
swingSetName="${setName}_swing"
swingNetSetName="${netSetName}_swing"
tmpFile="`mktemp`"
tmpFile2="`mktemp`"

[ -z "$rblList" ] && rblList="`uci -q get 'sub2rbl.@[0]'.rbl`"
unset whiteList
for x in `uci -q get 'sub2rbl.@[0].whitelist'` ; do
  whiteList="\"$x\"\\|$whiteList"
done
[ -n "$whiteList" ] ; then whiteList="${whiteList}\"^\$\""

# First we process our regular RBLs (IP based)
for rbl in $rblList ; do
  if [ ${rbl%%:*} = net ] ; then
    setType='net' 		# process net-based RBLs
    rbl="${rbl##net:}"
    tempSet="$netSetName"
  else
    setType='ip'		# default is IP-based (default)
    tempSet="$setName"
  fi
  createSet 1 "$tempSet" $setType
  createSet 2 "$tempSet"_swing $setType
  logLine 2 "Retrieving RBL ($rbl)"
  if ! errorMsg=`curl $curlArgs -o "$tmpFile" "$rbl" 2>&1`; then
    logLine 1 "Error: retrieving RBL($rbl): $errorMsg"
    continue
  fi
  logLine 3 "Processing RBL ($rbl)"

  if [ $setType = ip ] ; then
    # autodetect the DRG sshpwauth report
    egrep -v '^#' "$tmpFile" | head -1 | grep -q '^.*|.*|.*|.*|.*sshpwauth'
    if [ $? -eq 0 ] ; then
      logLine 3 "Loading DRG pwauth"
      sed -n 's/^.*|.*| *\([0-9\.][0-9\.]*\) .*$/\1/p' "$tmpFile" > "$tmpFile2"
    else
      logLine 3 "Loading plain IP list"
      sed -n 's/^ *\([0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\)[ 	]*.*$/\1/p' "$tmpFile" > "$tmpFile2"
    fi
  elif [ $setType = net ] ; then
      logLine 3 "Loading plain Net list"
      sed -n 's#^ *\([0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*[/0-9]*\)[ 	]*.*$#\1#p' "$tmpFile" > "$tmpFile2"
  fi
  if [ -n "$whiteList" ] ; then
    logLine 3 "Applying whitelist"
    eval egrep -v "$whiteList" "$tmpFile2" \> "$tmpFile"
    mv "$tmpFile" "$tmpFile2"
  fi
  sed -i "s/^/add "$tempSet"_swing /" "$tmpFile2"
  setSizeBefore=`ipset save "$tempSet"_swing | egrep '^add ' | wc -l`
  ipset restore -f "$tmpFile2" -\!
  setSize=`ipset save "$tempSet"_swing | egrep '^add ' | wc -l`
  logLine 1 "RBL ($rbl) added $((setSize - setSizeBefore)) entries"
done

rm -f "$tmpFile" "$tmpFile2"

for tempSet in "$setName" "$netSetName" ; do
  if ipset list -q -n "$tempSet"_swing >/dev/null ; then
    setupIPTables "$tempSet"
    logLine 3 "Swinging set $tempSet"
    ipset swap "$tempSet" "$tempSet"_swing
    removeSet 2 "$tempSet"_swing
  fi
done
